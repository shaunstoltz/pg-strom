<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="PG-Strom Development Team">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Release Note - PG-Strom Manual</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="//fonts.googleapis.com/earlyaccess/notosansjp.css" rel="stylesheet">
  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet">
  <link href="../custom.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Release Note";
    var mkdocs_page_input_path = "release_note.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> PG-Strom Manual</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
  [<a href="../ja/release_note/" style="color: #cccccc">Japanese</a> | <strong>English</strong>]
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../install/">Install</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Tutorial</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../operations/">Basic Operations</a>
                </li>
                <li class="">
                    
    <a class="" href="../sys_admin/">System Administration</a>
                </li>
                <li class="">
                    
    <a class="" href="../brin/">Index Support</a>
                </li>
                <li class="">
                    
    <a class="" href="../partition/">Partitioning</a>
                </li>
                <li class="">
                    
    <a class="" href="../troubles/">Trouble Shooting</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Advanced Features</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ssd2gpu/">SSD2GPU Direct SQL</a>
                </li>
                <li class="">
                    
    <a class="" href="../arrow_fdw/">Arrow_fdw</a>
                </li>
                <li class="">
                    
    <a class="" href="../python/">In-database Analytics</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">References</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ref_types/">Data Types</a>
                </li>
                <li class="">
                    
    <a class="" href="../ref_devfuncs/">Functions and Operators</a>
                </li>
                <li class="">
                    
    <a class="" href="../ref_sqlfuncs/">SQL Objects</a>
                </li>
                <li class="">
                    
    <a class="" href="../ref_params/">GUC Parameters</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Release Note</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#pg-strom-v23-release">PG-Strom v2.3 Release</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#overview">Overview</a></li>
        
            <li><a class="toctree-l3" href="#prerequisites">Prerequisites</a></li>
        
            <li><a class="toctree-l3" href="#new-features">New Features</a></li>
        
            <li><a class="toctree-l3" href="#significant-bug-fixes">Significant bug fixes</a></li>
        
            <li><a class="toctree-l3" href="#deprecated-features">Deprecated Features</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#pg-strom-v22-release">PG-Strom v2.2 Release</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#overview_1">Overview</a></li>
        
            <li><a class="toctree-l3" href="#prerequisites_1">Prerequisites</a></li>
        
            <li><a class="toctree-l3" href="#new-features_1">New Features</a></li>
        
            <li><a class="toctree-l3" href="#features-to-be-deprecated">Features to be deprecated</a></li>
        
            <li><a class="toctree-l3" href="#dropped-features">Dropped Features</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#pg-strom-v20-release">PG-Strom v2.0 Release</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#overview_2">Overview</a></li>
        
            <li><a class="toctree-l3" href="#prerequisites_2">Prerequisites</a></li>
        
            <li><a class="toctree-l3" href="#new-features_2">New Features</a></li>
        
            <li><a class="toctree-l3" href="#dropped-features_1">Dropped features</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">PG-Strom Manual</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Release Note</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="pg-strom-v23-release">PG-Strom v2.3 Release</h1>
<div style="text-align: right;">PG-Strom Development Team (1-Apr-2020)</div>

<h2 id="overview">Overview</h2>
<p>Major changes in PG-Strom v2.3 includes:
- GpuJoin supports parallel construction of inner buffer
- Arrow_Fdw now becomes writable; supports INSERT/TRUNCATE.
- pg2arrow command supports 'append' mode.
- mysql2arrow command was added.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>PostgreSQL v10, v11, v12</li>
<li>CUDA Toolkit 10.1 or later</li>
<li>Linux distributions supported by CUDA Toolkit</li>
<li>Intel x86 64bit architecture (x86_64)</li>
<li>NVIDIA GPU CC 6.0 or later (Pascal or Volta)</li>
</ul>
<h2 id="new-features">New Features</h2>
<ul>
<li>GpuJoin supports parallel construction of inner buffer<ul>
<li>The older version construct inner buffer of GpuJoin by the backend process only. This restriction leads a problem; parallel scan of partitioned table delays extremely.</li>
<li>This version allows both of the backend and worker processes to construct inner buffer. In case when we scan a partitioned table, any processes that is assigned to a particular child table can start GpuJoin operations immediately.</li>
</ul>
</li>
<li>Refactoring of the partition-wise asymmetric GpuJoin<ul>
<li>By the refactoring of the partition-wise asymmetric GpuJoin, optimizer becomes to prefer multi-level GpuJoin in case when it offers cheaper execution cost.</li>
</ul>
</li>
<li>Arrow_Fdw becomes writable; INSERT/TRUNCATE supported<ul>
<li>Arrow_Fdw foreign table allows bulk-loading by <code>INSERT</code> and data elimination by <code>pgstrom.arrow_fdw_truncate</code>.</li>
</ul>
</li>
<li>pg2arrow command supports 'append' mode.<ul>
<li>We added <code>--append</code> option for <code>pg2arrow</code> command. As literal, it appends query results on existing Apache Arrow file.</li>
<li>Also, <code>-t table</code> option was added as an alias of <code>SELECT * FROM table</code>.</li>
</ul>
</li>
<li>mysql2arrow command was added.<ul>
<li>We added <code>mysql2arrow</code> command that connects to MySQL server, not PostgreSQL, and write out SQL query results as Apache Arrow files.</li>
<li>It has equivalent functionality to <code>pg2arrow</code> except for enum data type. <code>mysql2arrow</code> saves enum values as flat Utf8 values without DictionaryBatch chunks.</li>
</ul>
</li>
<li>Regression test was added<ul>
<li>Several test cases were added according to the PostgreSQL regression test framework.</li>
</ul>
</li>
</ul>
<h2 id="significant-bug-fixes">Significant bug fixes</h2>
<ul>
<li>Revised cache invalidation logic for GPU device functions / types<ul>
<li>The older version had invalidated all the metadata cache entries of GPU device functions / type on execution of ALTER command. It was revised to invalidate the entries that are actually updated.</li>
</ul>
</li>
<li>Revised extreme performance degradation if GROUP BY has same grouping key twice or even number times.<ul>
<li>GpuPreAgg combined hash values of grouping key of GROUP BY using XOR. So, if case when same column appeared even number time, it always leads 0 for hash-index problematically. Now we add a randomization for better hash distribution.</li>
</ul>
</li>
<li>Potential infinite loop on GpuScan<ul>
<li>By uninitialized values, GpuScan potentially goes to infinite loop when SSD2GPU Direct SQL is available.</li>
</ul>
</li>
<li>Potential GPU kernel crash on GpuJoin<ul>
<li>By uninitialized values, GpuJoin potentially makes GPU kernel crash when 3 or more tables are joined.</li>
</ul>
</li>
</ul>
<h2 id="deprecated-features">Deprecated Features</h2>
<ul>
<li>PostgreSQL v9.6 Support<ul>
<li>CustomScan API in PostgreSQL v9.6 lacks a few APIs to handle dynamic shared memory (DSM). It has been a problem to handle a common code for v10 or later. To avoid the problem, we dropped PostgreSQL v9.6 support in this version.</li>
</ul>
</li>
<li>PL/CUDA<ul>
<li>According to the usecase analytics, users prefer familiar programming language environment like Python, rather than own special environment.</li>
<li>A combination of Arrow_Fdw's GPU export functionality and CuPy invocation at PL/Python is a successor of PL/CUDA, for in-database machine-learning / statistical analytics.</li>
</ul>
</li>
<li>Gstore_Fdw<ul>
<li>This feature is replaced by the writable Arrow_Fdw and its GPU export functionality.</li>
</ul>
</li>
<li>Largeobject export to/import from GPU<ul>
<li>According to the usecase analytics, we determined this feature is not needed.</li>
</ul>
</li>
</ul>
<h1 id="pg-strom-v22-release">PG-Strom v2.2 Release</h1>
<div style="text-align: right;">PG-Strom Development Team (1-May-2019)</div>

<h2 id="overview_1">Overview</h2>
<p>Major enhancement in PG-Strom v2.2 includes:</p>
<ul>
<li>Table partitioning support</li>
<li>Columnar store support with Arrow_Fdw</li>
<li>Pre-built GPU binary support</li>
<li>Enables to implement GPU functions that returns variable length data</li>
<li>GpuSort support on GPU memory store (Gstore_Fdw)</li>
<li>NVME-oF support (Experimental)</li>
</ul>
<h2 id="prerequisites_1">Prerequisites</h2>
<ul>
<li>PostgreSQL v9.6, v10, v11</li>
<li>CUDA Toolkit 10.1</li>
<li>Linux distributions supported by CUDA Toolkit</li>
<li>Intel x86 64bit architecture (x86_64)</li>
<li>NVIDIA GPU CC 6.0 or later (Pascal or Volta)</li>
</ul>
<h2 id="new-features_1">New Features</h2>
<ul>
<li>Table partitioning support<ul>
<li>If multi-GPUs configuration, an optimal GPU shall be chosen according to the physical distance between GPU and child tables that construct a partition. If PG-Strom cannot identify the distance from PCIe-bus topology, like NVME-oF configuration, DBA can configure the relation of GPU and NVME-SSD using <code>pg_strom.nvme_distance_map</code>.</li>
<li>When we join a partitioned table with non-partition tables, this version can produce a query execution plan that preliminary joins the non-partitioned table with partition child tables for each, and gather the results from child tables. This feature is proposed to PostgreSQL v13 core, as Asymmetric Partition-wise JOIN.</li>
</ul>
</li>
<li>Columnar store support with Arrow_Fdw<ul>
<li>It supports to read external Apache Arrow files using foreign table.</li>
<li>It also supports SSD-to-GPU Direct SQL on Apache Arrow files.</li>
</ul>
</li>
<li>Pre-built GPU binary support<ul>
<li>When GPU binary code is generated from SQL, the older version wrote out eitire CUDA C source code, including static portions like libraries, then NVRTC(NVIDIA Run-Time Compiker) built them on the fly. However, a part of complicated function consumed much longer compilation time.</li>
<li>v2.2 preliminary builds static functions preliminary, and only dynamic portion from SQL are built dynamically. It reduces the time for GPU binary generation.</li>
</ul>
</li>
<li>JSONB data type support<ul>
<li>This version allows to reference elements of JSONB object, and to utilize them as <code>numeric</code> or <code>test</code>.</li>
</ul>
</li>
<li>Enables to implement GPU functions that returns variable length data<ul>
<li>This version allows to implement SQL functions that returns variable-length data, like <code>textcat</code>, on GPU devices.</li>
</ul>
</li>
<li>GpuSort support on GPU memory store (Gstore_Fdw)<ul>
<li>This version allows to read data from GPU memory store for SQL workloads execution, not only PL/CUDA.</li>
</ul>
</li>
<li>Addition of regression test<ul>
<li>Several simple regression tests are added.</li>
</ul>
</li>
<li>NVME-oF support (Experimental)<ul>
<li>It supports SSD-to-GPU Direct SQL from remote SSD disks which are mounted using NVME-over-Fabric. Please note that it is an experimental feature, and it needs to replace the <code>nvme_rdma</code> kernel module on Red Hat Enterprise Linux 7.x / CentOS 7.x.</li>
</ul>
</li>
</ul>
<h2 id="features-to-be-deprecated">Features to be deprecated</h2>
<ul>
<li>
<p>PostgreSQL v9.6 support</p>
<ul>
<li>CustomScan API in PostgreSQL v9.6 lacks a few APIs to handle dynamic shared memory (DSM), so it is unable to collect run-time statistics.</li>
<li>It also changes the way to keep expression objects internally, therefore, we had to put <code>#if ... #endif</code> blocks at no little points. It has damaged to code maintainability.</li>
<li>Due to the problems, this is the last version to support PostgreSQL v9.6. If you applied PG-Strom on PostgreSQL v9.6, let us recommend to move PostgreSQL v11 as soon as possible.</li>
</ul>
</li>
<li>
<p>The <code>pgstrom</code> format of Gstore_Fdw foreign table</p>
<ul>
<li>The internal data format on GPU memory store (Gstore_Fdw) is originally designed for data source of PL/CUDA procedures. It is our own format, and used PostgreSQL's data representations as is, like variable-length data, numeric, and so on.</li>
<li>After that, NVIDIA released RAPIDS(cuDF), based on Apache Arrow, for data exchange on GPU, then its adoption becomes wider on machine-learning application and Python software stack.</li>
<li>PG-Strom will switch its internal data format of Gstore_Fdw, to improve interoperability with these machine-learning software, then existing data format shall be deprecated.</li>
</ul>
</li>
</ul>
<h2 id="dropped-features">Dropped Features</h2>
<ul>
<li>In-memory columnar cache<ul>
<li>As results of use-case analysis, we concluded Arrow_Fdw can replace this feature in most cases. Due to feature duplication, we dropped the in-memory columnar cache.</li>
</ul>
</li>
</ul>
<h1 id="pg-strom-v20-release">PG-Strom v2.0 Release</h1>
<div style="text-align: right;">PG-Strom Development Team (17-Apr-2018)</div>

<h2 id="overview_2">Overview</h2>
<p>Major enhancement in PG-Strom v2.0 includes:</p>
<ul>
<li>Overall redesign of the internal infrastructure to manage GPU and stabilization</li>
<li>CPU+GPU hybrid parallel execution</li>
<li>SSD-to-GPU Direct SQL Execution</li>
<li>In-memory columnar cache</li>
<li>GPU memory store (gstore_fdw)</li>
<li>Redesign of GpuJoin and GpuPreAgg and speed-up</li>
<li>GpuPreAgg + GpuJoin + GpuScan combined GPU kernel</li>
</ul>
<p>You can download the summary of new features from: <a href="../blob/20180417_PGStrom_v2.0_TechBrief.pdf">PG-Strom v2.0 Technical Brief</a>.</p>
<h2 id="prerequisites_2">Prerequisites</h2>
<ul>
<li>PostgreSQL v9.6, v10</li>
<li>CUDA Toolkit 9.1</li>
<li>Linux distributions supported by CUDA Toolkit</li>
<li>Intel x86 64bit architecture (x86_64)</li>
<li>NVIDIA GPU CC 6.0 or later (Pascal or Volta)</li>
</ul>
<h2 id="new-features_2">New Features</h2>
<ul>
<li>
<p>Entire re-design and stabilization of the internal infrastructure to manage GPU device.</p>
<ul>
<li>PostgreSQL backend process simultaneously uses only one GPU at most. In case of multi-GPUs installation, it assumes combination use with CPU parallel execution of PostgreSQL. Usually, it is not a matter because throughput of CPU to provide data to GPU is much narrower than capability of GPU processors. We prioritized simpleness of the software architecture.</li>
<li>We began to utilize the demand paging feature of GPU device memory supported at the GPU models since Pascal generation. In most of SQL workloads, we cannot know exact size of the required result buffer prior to its execution, therefore, we had allocated more buffer than estimated buffer length, and retried piece of the workloads if estimated buffer size is not sufficient actually. This design restricts available resources of GPU which can be potentially used for other concurrent processes, and complicated error-retry logic was a nightmare for software quality. The demand paging feature allows to eliminate and simplify these stuffs.</li>
<li>We stop to use CUDA asynchronous interface. Use of the demand paging feature on GPU device memory makes asynchronous APIs for DMA (like <code>cuMemCpyHtoD</code>) perform synchronously, then it reduces concurrency and usage ratio of GPU kernels. Instead of the CUDA asynchronous APIs, PG-Strom manages its own worker threads which call synchronous APIs for each. As a by-product, we also could eliminate asynchronous callbacks (<code>cuStreamAddCallback</code>), it allows to use MPS daemon which has a restriction at this API.</li>
</ul>
</li>
<li>
<p>CPU+GPU Hybrid Parallel Execution</p>
<ul>
<li>CPU parallel execution at PostgreSQL v9.6 is newly supported.</li>
<li>CustomScan logic of GpuScan, GpuJoin and GpuPreAgg provided by PG-Strom are executable on multiple background worker processes of PostgreSQL in parallel.</li>
<li>Limitation: PG-Strom's own statistics displayed at <code>EXPLAIN ANALYZE</code> if CPU parallel execution. Because PostgreSQL v9.6 does not provide <code>ShutdownCustomScan</code> callback of the CustomScan interface, coordinator process has no way to reclaim information of worker processes prior to the release of DSM (Dynamic Shared Memory) segment.</li>
</ul>
</li>
<li>
<p>SSD-to-GPU Direct SQL Execution</p>
<ul>
<li>By cooperation with the <code>nvme_strom</code> Linux kernel module, it enables to load PostgreSQL's data blocks on NVMe-SSD to GPU device memory directly, bypassing the CPU and host buffer. This feature enables to apply PG-Strom on the area which have to process large data set more than system RAM size.</li>
<li>It allows to pull out pretty high throughput close to the hardware limitation because its data stream skips block-device or filesystem layer. Then, GPU runs SQL workloads that usually reduce the amount of data to be processed by CPU. The chemical reaction of these characteristics enables to redefine GPU's role as accelerator of I/O workloads also, not only computing intensive workloads.</li>
</ul>
</li>
<li>
<p>In-memory Columnar Cache</p>
<ul>
<li>For middle size data-set loadable onto the system RAM, it allows to cache data-blocks in column format which is more suitable for GPU computing. If cached data-blocks are found during table scan, PG-Strom prefers to reference the columnar cache more than shared buffer of PostgreSQL.</li>
<li>In-memory columnar cache can be built synchronously, or asynchronously by the background workers.</li>
<li>You may remember very early revision of PG-Strom had similar feature. In case when a cached tuple gets updated, the latest in-memory columnar cache which we newly implemented in v2.0 invalidates the cache block which includes the updated tuples. It never updates the columnar cache according to the updates of row-store, so performance degradation is quite limited.</li>
</ul>
</li>
<li>
<p>GPU Memory Store (gstore_fdw)</p>
<ul>
<li>It enables to write to / read from preserved GPU device memory region by SELECT/INSERT/UPDATE/DELETE in SQL-level, using foreign table interface.</li>
<li>In v2.0, only <code>pgstrom</code> internal data format is supported. It saves written data using PG-Strom's buffer format of <code>KDS_FORMAT_COLUMN</code>. It can compress variable length data using LZ algorithm.</li>
<li>In v2.0, GPU memory store can be used as data source of PL/CUDA user defined function.</li>
</ul>
</li>
<li>
<p>Redesign and performance improvement of GpuJoin and GpuPreAgg</p>
<ul>
<li>Stop using Dynamic Parallelism which we internally used in GpuJoin and GpuPreAgg, and revised entire logic of these operations. Old design had a problem of less GPU usage ratio because a GPU kernel which launches GPU sub-kernel and just waits for its completion occupied GPU's execution slot.</li>
<li>A coproduct of this redesign is suspend/resume of GpuJoin. In principle, JOIN operation of SQL may generate larger number of rows than number of input rows, but preliminary not predictive. The new design allows to suspend GPU kernel once buffer available space gets lacked, then resume with new result buffer. It simplifies size estimation logic of the result buffer, and eliminates GPU kernel retry by lack of buffer on run-time.</li>
</ul>
</li>
<li>
<p>GpuPreAgg+GpuJoin+GpuScan combined GPU kernel</p>
<ul>
<li>In case when GPU executable SCAN, JOIN and GROUP BY are serially cascaded, a single GPU kernel invocation runs a series of tasks equivalent to the GpuScan, GpuJoin and GpuPreAgg. This is an approach to minimize data exchange between CPU and GPU. For example, result buffer of GpuJoin is used as input buffer of GpuPreAgg.</li>
<li>This feature is especially valuable if combined with SSD-to-GPU Direct SQL Execution.</li>
</ul>
</li>
<li>
<p>PL/CUDA Enhancement</p>
<ul>
<li><code>#plcuda_include</code> is enhanced to specify SQL function which returns <code>text</code> type. It can change the code block to inject according to the argument, so it also allows to generate multiple GPU kernel variations, not only inclusion of externally defined functions.</li>
<li>If PL/CUDA takes <code>reggstore</code> type argument, GPU kernel function receives pointer of the GPU memory store. Note that it does not pass the OID value.</li>
</ul>
</li>
<li>
<p>Other Enhancement</p>
<ul>
<li><code>lo_import_gpu</code> and <code>lo_export_gpu</code> functions allows to import contents of the GPU device memory acquired by external applications directly, or export contents of the largeobject to the GPU device memory.</li>
</ul>
</li>
<li>
<p>Packaging</p>
<ul>
<li>Add RPM packages to follow the PostgreSQL packages distributed by PostgreSQL Global Development Group.</li>
<li>All the software packages are available at HeteroDB SWDC(Software Distribution Center) and downloadable.</li>
</ul>
</li>
<li>
<p>Document</p>
<ul>
<li>PG-Strom documentation was entirely rewritten using markdown and mkdocs. It makes documentation maintenance easier than the previous HTML based approach, so expects timely updates according to the development of new features.</li>
</ul>
</li>
<li>
<p>Test</p>
<ul>
<li>Regression test for PG-Strom was built on top of the regression test framework of PostgreSQL.</li>
</ul>
</li>
</ul>
<h2 id="dropped-features_1">Dropped features</h2>
<ul>
<li>
<p>PostgreSQL v9.5 Support</p>
<ul>
<li>PostgreSQL v9.6 had big changes in both of the optimizer and executor to support CPU parallel query execution. The biggest change for extension modules that interact them is an enhancement of the interface called "upper planner path-ification". It allows to choose an optimal execution-plan from the multiple candidates based on the estimated cost, even if it is aggregation or sorting.</li>
<li>It is fundamentally different from the older way where we rewrote query execution plan to inject GpuPreAgg using the hooks. It allows to inject GpuPreAgg node in more reasonable and reliable way, and we could drop complicated (and buggy) logic to rewrite query execution plan once constructed.</li>
<li>CustomScan interface is also enhanced to support CPU parallel execution. Due to the reason, we dropped PostgreSQL v9.5 support to follow these new enhancement.</li>
</ul>
</li>
<li>
<p>GpuSort feature</p>
<ul>
<li>We dropped GpuSort because we have little advantages in the performance.</li>
<li>Sorting is one of the GPU suitable workloads. However, in case when we try to sort data blocks larger than GPU device memory, we have to split the data blocks into multiple chunks, then partially sort them and merge them by CPU to generate final results.</li>
<li>Larger chunk size is better to reduce the load to merge multiple chunks by CPU, on the other hands, larger chunk size takes larger lead time to launch GPU kernel to sort. It means here is a trade-off; which disallows asynchronous processing by PG-Strom to make data transfer latency invisible.</li>
<li>It is hard to solve the problem, or too early to solve the problem, we dropped GpuSort feature once.</li>
</ul>
</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../ref_params/" class="btn btn-neutral" title="GUC Parameters"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../ref_params/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
